#!/usr/bin/env bash
# .project_defaults : project_defaults for repo setup (version 0.0.1)

# usage: source "/path/to/this/file/.project_defaults"

# author    - Michael Treanor  <skeptycal@gmail.com>
# copyright - 2019 (c) Michael Treanor
# license   - MIT <https://opensource.org/licenses/MIT>
# github    - https://www.github.com/skeptycal
###############################################################################
. $(which ssm) >/dev/null 2>&1  # import standard script modules, if available

#! ############################################ (CHANGE THESE TO YOURS)
    # Identify default settings path
    # default is the folder that this global script is running from

    # (location for default copies of .info.cfg, .gitignore, README.md
    # .travis.yml, bitbucket_pipelines.yml, codedov.yml, gpg_public.txt
    # requirements.txt, Pipfile, setup.py, .pre-commit-config.yaml, etc)

    # you may adjust as needed to use a separate settings folder
    # (e.g.) template_path="$HOME/path/to/my/settings/"

    # user's ~/bin folder
    declare -x BIN_DIR && BIN_DIR=$(realpath $HOME/bin)
    # directory where project defaults are stored
    declare -x template_path=${template_path:-"$HOME/Documents/coding/template"}
    # current directory
    export here=$PWD
    # backup directory (non source control - for dev tests only)
    declare -x backup_dir="${here}/bak"

    # set backup directory; create if needed
    [[ -d "${backup_dir}" ]] || mkdir -p "$backup_dir" >/dev/null 2>&1


    # Set default readme file (usually <md> or <rst>)
    #    (<1st>, <now>, <txt>, or <asc> are older forms.)
    export readme="${here}/README.md"

    ME=${0##*/}                     # name of this script
    ARGS=( ${@:1} )                 # list of cli arguments passed, including FILES to link

    # is color available or not
    declare -ix USE_COLOR
    [[ -t 0 ]] && USE_COLOR=1 || USE_COLOR=0

#* ############################################ utilities
function check_file() {
    # testing file properties
    # parameter: $1 - name of file to check
    # return: $check_file_output - list of file properties
    local name=$1
    local path=(${!1})
    # echo "name: $name"
    # echo "path: $path"
    local tmp_chk=''
    [[ -e "$path" ]] && tmp_chk="${tmp_chk} exists" || tmp_chk="${tmp_chk} does-not-exist"
    [[ -f "$path" ]] && tmp_chk="${tmp_chk} regular"
    [[ -L "$path" ]] && tmp_chk="${tmp_chk} link"
    [[ -d "$path" ]] && tmp_chk="${tmp_chk} directory"
    [[ -r "$path" ]] && tmp_chk="${tmp_chk} readable"
    [[ -s "$path" ]] && tmp_chk="${tmp_chk} size>0"
    [[ -w "$path" ]] && tmp_chk="${tmp_chk} writable"
    [[ -x "$path" ]] && tmp_chk="${tmp_chk} executable"
    [[ -O "$path" ]] && tmp_chk="${tmp_chk} owned-by-me"
    [[ -N "$path" ]] && tmp_chk="${tmp_chk} dirty"
    [[ -k "$path" ]] && tmp_chk="${tmp_chk} sticky"
    # echo " ->$tmp_chk"
    # echo ''
    check_file_output=$tmp_chk
}

bak() {
    # backup files to backup directory
    #   (while this is a handy thing on some occasions, please prefer source
    #   control using Git/GitHub or similar)
    #   if no backup directory is set, use ./bak/
    #   add extension .bak to all files
    backup_dir=${backup_dir:-"${here}/bak"}
    for f in $*; do
        bak_file=${f##*/}
        source=$(realpath $f)
        target="${backup_dir}/${f##*/}.bak"
        if [[ -r "$f" ]]; then
            cp -f $source $target &>/dev/null
        else
            attn "Cannot backup $f"
        fi
    done
}

###############################################################################
# cli check
fd=0 # stdin
if [ -t "$fd" ]; then
    # interactive
    echo "This script was not intended to be run directly."
else
    # non-interactive
    initialize
fi
