#!/usr/bin/env zsh
# -*- coding: utf-8 -*-
# shellcheck shell=bash
# shellcheck source=/dev/null
# shellcheck disable=2230

# cannot be run directly; called from .bash_profile or .bashrc
#?#- ##########################- ############################################
#* .functions - functions for standard script modules (ssm)
#* copyright (c) 2019 Michael Treanor
#* MIT License - https://www.github.com/skeptycal


. "$(which ssm)"

#TODO find this text ... _pretty_usage
_pretty_usage=''

# set -a
declare -ix SET_DEBUG && SET_DEBUG=${SET_DEBUG:-0} # set to 1 for verbose testing

declare -x VERSION_LIST && VERSION_LIST="${DOTFILES_PATH}/.VERSION_LIST.md"

# get name for 'open' if linux or windows
if [ ! "$(uname -s)" = 'Darwin' ]; then
    if grep -q Microsoft /proc/version; then
        alias open='explorer.exe'
    else
        alias open='xdg-open'
    fi
fi
# use git diff if available
if [[ "$(hash git &>/dev/null)" -eq 0 ]]; then
    function diff() {
        git diff --no-index --color-words "$@"
    }
fi

# - #- ################################
# - utilities from https://justin.abrah.ms/dotfiles/zsh.html

# Nifty extras
alias servethis="python -c 'import SimpleHTTPServer; SimpleHTTPServer.test()'"
alias pypath='python -c "import sys; print(sys.path)" | tr "," "\n" | grep -v "egg"'
alias pycclean='find $PWD -name "*.pyc" -exec rm {} \; && find $PWD -name "__pycache__" -exec rm -rf {} \;'
alias ssh='ssh -R 10999:localhost:22'
alias nethack='telnet nethack.alt.org'

# curl for useragents
alias iecurl="curl -H \"User-Agent: Mozilla/5.0 (Windows; U; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727)\""
alias ffcurl="curl -H \"User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.0.8) Gecko/2009032609 Firefox/3.0.0 (.NET CLR 3.5.30729)\""

killit() {
    # Kills any process that matches a regexp passed to it
    ps aux | grep -v "grep" | grep "$@" | awk '{print $2}' | xargs sudo kill
}
portslay () {
    kill -9 `lsof -i tcp:$1 | tail -1 | awk '{ print $2;}'`
}
ghget () {
    # input: rails/rails
    USER=$(echo $@ | tr "/" " " | awk '{print $1}')
    REPO=$(echo $@ | tr "/" " " | awk '{print $2}')
    mcd "$HOME/src/github.com/$USER" && \
    hub clone $@ && \
    cd $REPO
}
exip () {
    # gather external ip address
    echo -n "Current External IP: "
    curl -s -m 5 http://myip.dk | grep "ha4" | sed -e 's/.*ha4">//g' -e 's/<\/span>.*//g'
}

ipaddr () {
    # determine local IP address
    ifconfig | grep "inet " | awk '{ print $2 }'
}
parse_git_branch(){
    git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/[\1] /';
}

parse_svn_rev(){
    svn info 2> /dev/null | grep "Revision" | sed 's/Revision: \(.*\)/[r\1] /';
}

update_git_dirs() {
    # so what the below does is finds all files named .git in my home
    # directory, but excludes the .virtualenvs folder then strips the .git from
    # the end, cd's into the directory, pulls from the origin master, then
    # repeats

    OLD_DIR=`pwd`
    cd ~
    for i in `find . -type d -name ".virtualenvs" -prune -o -name ".git" | sed 's/\.git//'`; do
        echo "Going into $i"
        cd $i
        git pull origin master
        cd ~
    done
    cd $OLD_DIR
}
shell () {
  ps | grep `echo $$` | awk '{ print $4 }'
}
unegg () {
    unzip $1 -d tmp
    rm $1
    mv tmp $1
}

unpatch () {
  find . -name "*.orig" -o -name "*.rej"  -type f -exec rm {} \;
  find . -name "b" -type d -exec rm -rf {} \;
}
set_gamma () {
  xrandr --output eDP1 --gamma $1:$1:$1
}

cs_on() {
  set_gamma 1.7
}

cs_off()  {
  set_gamma 1.0
}

dls () {
 # directory LS
 echo `ls -l | grep "^d" | awk '{ print $9 }' | tr -d "/"`
}
dgrep() {
    # A recursive, case-insensitive grep that excludes binary files
    grep -iR "$@" -- * | grep -v "Binary"
}
dfgrep() {
    # A recursive, case-insensitive grep that excludes binary files
    # and returns only unique filenames
    grep -iR "$@" -- * | grep -v "Binary" | sed 's/:/ /g' | awk '{ print $1 }' | sort | uniq
}
psgrep() {
    if [ -n "$1" ] ; then
        echo "Grepping for processes matching $1..."
        ps aux | grep "$1" | grep -v grep
    else
        echo "!! Need name to grep for"
    fi
}
# - ######################## TODO - WORKS IN PROGRESS

dict() {
    grep "$@" /usr/share/dict/words
}

extract () {
    if [ -f "$1" ] ; then
        case $1 in
            *.tar.bz2)        tar xjf "$1"        ;;
            *.tar.gz)         tar xzf "$1"        ;;
            *.bz2)            bunzip2 "$1"        ;;
            *.rar)            unrar x "$1"        ;;
            *.gz)             gunzip "$1"         ;;
            *.tar)            tar xf "$1"         ;;
            *.tbz2)           tar xjf "$1"        ;;
            *.tgz)            tar xzf "$1"        ;;
            *.zip)            unzip "$1"          ;;
            *.Z)              uncompress "$1"     ;;
            *.7z)             7zr e "$1"          ;;
            *)                echo "'$1' cannot be extracted via extract()" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

# hardlink_dotfiles(){
#     -  convert symlinks to hardlinks
#     ls "$HOME/.dotfiles" -A | perl -nle 'print if -l and not -d;'

#     while IFS="" read -r f || [ -n "$f" ]
#     do
#         f=
#         printf '%s\n' "$p"
#         unlink ""
#         ln "$HOME/.dotfiles/$p" "$HOME"
#     done < lsln.txt
# }

py_realpath(){
    python3 -c "
import os
import sys
for item in sys.argv[1:]:
    print(item, os.path.realpath(item). )
" "$@"
}

which() { command -v "$@"; }

replace() {
    if [[ -z "$1" ]]; then
        attn $'missing argument ...'
        me $'\nUsage: replace ORIGINAL [NEW] [FILES...]'
        exit "$EX_USAGE"
    fi
    ORIGINAL="$1"
    REPLACEMENT="${2:-}"
    FILES="${3:-'.'}"

# shellcheck disable=2086,2013
for word in $(grep -Fl $ORIGINAL $FILES)
do
  # -------------------------------------
  ex $word <<EOF
  :%s/$ORIGINAL/$REPLACEMENT/g
  :wq
EOF
  # :%s is the "ex" substitution command.
  # :wq is write-and-quit.
  # -------------------------------------
done
}

# Ref: https://unix.stackexchange.com/questions/22815/how-to-list-files-and-directories-with-directories-first
function l1() { # nice sorting ... #TODO no color ...
    # shellcheck disable=2012
    ls -l "$@" | sort -r | awk 'NF==9 { if ($1~/^d/) { print $9 "/" } else { print $9 } }'
}

update () {
    # System software updates (macOS - updated for Catalina)
    #- #- ##########################- ############################################
    # Close any open System Preferences panes, to prevent them from overriding
    # settings we’re about to change
    osascript -e 'tell application "System Preferences" to quit'

    # Ask for the administrator password upfront
    /usr/bin/sudo -v

    # Keep-alive: update existing `sudo` time stamp until 'update' has finished
    while true; do
        /usr/bin/sudo -n true
        sleep 60
        kill -0 "$$" || exit
    done 2>/dev/null &
    #- #- ##########################- ############################################

    /usr/bin/sudo softwareupdate -i -a
    brew update
    brew upgrade
    brew doctor
    brew cleanup
    # python
    #   brew upgrade python pyenv pipenv
    pip3 install -U pip
    pip3 list --outdated | cut -d ' ' -f1 | xargs -n1 pip install -U
    # npm
    #   brew upgrade node
    /usr/bin/sudo npm install npm -g
    /usr/bin/sudo npm update -g
    # ruby
    /usr/bin/sudo gem update --system
    /usr/bin/sudo gem update
    /usr/bin/sudo gem cleanup
} # 2>/dev/null &

cleanup () {
    # maintenance
    update &
    # cleanup .DS_Store files
    find . -type f -name '*.DS_Store' -ls -delete
    # empty trashes
    /usr/bin/sudo rm -rfv /Volumes/*/.Trashes; sudo rm -rfv ~/.Trash; sudo rm -rfv /private/var/log/asl/*.asl; sqlite3 ~/Library/Preferences/com.apple.LaunchServices.QuarantineEventsV* 'delete from LSQuarantineEvent'
    # lscleanup
    /System/Library/Frameworks/CoreServices.framework/Frameworks/LaunchServices.framework/Support/lsregister -kill -r -domain local -domain system -domain user && killall Finder
}

_mkdir(){
        [ $# -eq 0 ] && { echo "$0: dirname"; return; }
        local d="$1"               # get dir name
        local m=${2:-0755}         # get permission, set default to 0755
        # shellcheck disable=2174
        [ ! -d "$d" ] && mkdir -m "$m" -p "$d"
}

unbak(){
    find . -name "*.bak" -type f -print0 | xargs -0 /bin/rm -f
}

gather_del() {
    find . -name "${1:-}" -type f -print0 | xargs -0 /bin/rm -f
}

safe_split() {
    # use custom IFS for safe word splitting of oddly formatted strings
    if [ -z "$2" ]; then
        attn "Usage: safe_split <DELIMITER> <DATA (array | string | file)>"
    else
        IFS="$1"
        shift
        ce "$*"
    fi
}

ind() {
    lime Indirect Variable Tests

    value of

    me "echo tests"
    br
    # shellcheck disable=SC2016,SC2086
    ce '  var name (\$1):'"\t\t"            \$$1
    # shellcheck disable=SC2016,SC2086
    ce '  printf "$1":'"\t\t"           "$1"
    # shellcheck disable=SC2016,SC2086
    ce "  printf '\$1':""\t\t"          '$1'
    # shellcheck disable=SC2016,SC2086
    ce '  printf \$1:'"\t\t"         \$$1
    # shellcheck disable=SC2016,SC2086
    ce '  printf "\$$1":'"\t"       "\$$1"
    br
    me "eval tests"
    br
    # shellcheck disable=SC2016,SC2086
    attn '  printf $1:'"\t\t"
    # shellcheck disable=SC2016,SC2086
    eval echo -e $1
    # shellcheck disable=SC2016,SC2086
    attn '  printf "$1":'"\t"
    eval echo -e "$1"
    attn "  printf '\$1':""\t"
    eval echo -e '$1'
    # shellcheck disable=SC2016,SC2086
    attn '  printf \$1:'"\t\t"
    # shellcheck disable=SC2016,SC2086
    eval echo -e \$$1
    # shellcheck disable=SC2016,SC2086
    attn '  printf "\$$1":'"\t"
    eval echo -e "\$$1"
}
path() { # alias path='echo -e ${PATH//:/\\n}'
    if [[ -z "$1" ]]; then  # no arguments given ... print path
        green "$( echo -e "${PATH//:/\\n}" )"
    elif [ -d "$1" ]; then # if $1 is a directory, highlight the path entries

        IFS=":"
        typeset -a path_list
        # shellcheck disable=SC2207
        path_list=( $( IFS=":" echo -e "$1"; ) )
        echo -e "${path_list[@]}"
        echo -e "#-> -----------------#"
        for s in ${path_list[*]}
        # for s in "${path_list}"
        do
            if [ -h "$s" ]; then
                cool "$s"
            elif [ -d "$s" ]; then
                warn "$s"
            elif [ -x "$s" ]; then
                lime "$s"
            elif [ -O "$s" ]; then
                me "$s"
            elif [ -S "$s" ]; then
                canary "$s"
            elif [ -k "$s" ]; then
                rain "$s"
            elif [ -f "$s" ]; then
                ce "$s"
            else
                cherry "$s"
            fi
        done
        unset 'path_list[-1]'

        # ???❯ for line in ${PATH//:/ } ; do; echo $RANDOM$line; done;
    else #  if $1 is not a directory, treat it as a : delimited list ($1 is search term)
        needle="$1"
        shift
        echo -e ${${@}//:/\\n} | grep --color ''"$needle"
    fi
}


gather() {
    # gather - an easy way to gather similar files and do something with them
    #   designed for xargs (GNU findutils) 4.7.0 on macOS Catalina. ymmv
    #   Usage: xargs [OPTION]... COMMAND [INITIAL-ARGS]...
    #   installed with: <brew install findutils>
    gather_test=1 # reset test flag (0|1) (set to 1 for testing)

    #- ######################### process options
        option_string='-0' # default options (-0 is required to work with find -print0)
        if [ -z "$1" ]; then # if no args, exit with usage and error message
            me "$0 ${WHITE:-}[-huv] [-0opt] [xargs options] filetype [utility]"
            attn "error ${EX_USAGE} : a 'filetype' to gather is required" #TODO fix this so I can also lookup text
            return "$EX_USAGE" #TODO and make a shell function to search from the command line or list error codes
        else # process initial options
            case "$1" in
                -h|--help|help|'')
                    me "$GATHER_USAGE"
                    return 0
                ;;
                -u|--usage|usage)
                    me "$0 ${WHITE:-}[-huv] [-0opt] [xargs options] filetype [utility]"
                    return 0
                ;;
                -v|--version|version)
                    me "$0 version $VERSION"
                    ce "$(xargs --version)"
                    return 0
                ;;
                test)
                    gather_test=1
                    shift
                ;;
            esac
        fi
        while [[ ${1:0:1} == '-' ]]; do # process additional options
            option_string+="$1" # add them to the string
            shift
        done

    #- ######################### cleanup options
        option_string=${option_string//0/}'0' # remove all 0 and add a single one (-0 is required)
        option_string='-'${option_string//-/} # remove any '-' symbols and add a single one (formatting)

    #- ######################### setup search pattern
        # default filetype is pdf ... imo, least likely to cause headaches if they are moved accidentally
        gather_pattern=\*"${1:-pdf}"\*
        shift

    #- ######################### setup command
        # remaining args are considered the xargs 'command' or 'utility' and its arguments (default /bin/echo)
        command_string="${*:-/bin/echo}"

    #! ######################## testing
        if [[ $gather_test == 1 ]]; then
            br
            lime "Gathering all files like ${MAIN:-}${gather_pattern}${LIME:-} in current path and recursively."
            green "pwd:                  $PWD"
            green "option_string:        $option_string"
            green "gather_pattern:       $gather_pattern"
            green "command_string:       $command_string"
            br
            blue "# find -x . -name '$gather_pattern' -print0 | xargs $option_string $command_string"
            br

            # mkdir -p ~/books/_new/${gather_pattern//./} >/dev/null
            # find . -name "*.bak" -type f -print0 | xargs0
            # green "$( find . -name \'$gather_pattern\' -type f -print0 | xargs $option_string $command_string )"
        fi
    # issue final command to shell functions - pipe output where you like
    canary "$(find . -name "$gather_pattern" -print0 | xargs "$option_string" "$command_string")"
    # find . -name $gather_pattern -print0 |xargs -0
}
gst(){
    echo "if [ -n $1 ]; then cd $1; $(git status >/dev/null 2>&1; echo $?;)"
}

gitit() {
    if ! [ -d "$PWD/.git" ]; then
        warn "Git repo not found in .../${PWD##*/}/.git"
    else
        /usr/local/bin/git status
        if "$?"; then # >/dev/null 2>&1
            warn "Git status error: $PWD"
        else
            message="${*:-$(cat ~/.dotfiles/.stCommitMsg)}"
            blue "GitIt - add and commit all updates."
            green "  repo: ${PWD##*/}"
            green "  message: "
            green "$message"
            git add --all >/dev/null 2>&1
            pre-commit >/dev/null 2>&1
            git add --all
            pre-commit
            git commit -m "$message"
            git push --set-upstream origin "$(git_current_branch)"
        fi
    fi
}
# TODO - Declare if not declared
    # Reference: https://linuxhint.com/bash_declare_command/
    # if foo is not declared
    # declare it
    # else use available foo
    # test ! $( declare -F foo ) || {
    #     foo() { true ; }
    # }
#? ######################## BEGIN FUNCTIONS
a() { alias | grep "$1"; }

allopen() { sudo lsof -i -P | grep "$1"; }

anyguard() {
    ANYBAR_PORT="$(jot -r 1 1700 1900)"
    ANYBAR_PORT="$ANYBAR_PORT" open -n /Applications/AnyBar.app
    sleep 0.5
    anybar orange "$ANYBAR_PORT"
    eval "$@"
    ret="$?"
    if [[ ret -eq 0 ]]; then
        anybar green "$ANYBAR_PORT"
    else
        anybar red "$ANYBAR_PORT"
    fi
    echo "Finished. Press [ENTER] to exit."
    # shellcheck disable=2034
    IFS="" read -r ENTER
    anybar quit "$ANYBAR_PORT"
    return "$ret"
}
anybar() {
    echo -n "$1" | nc -4u -w0 localhost "${2:-1738}"
}
azure_agent() {
    # svc.sh only seems to work when run from its own directory ...
    # added default parameter 'status'
    local temp_pwd="$PWD"
    cd "$AZURE_WORKING_DIR" || return
    "${AZURE_WORKING_DIR}/svc.sh" "${1:-'status'}"
    result="$?"
    cd "$temp_pwd" || return
    unset temp_pwd
    return $result
}
bak() {
    FILES="$*"
    [[ -d "$PWD/bak" ]] || mkdir "$PWD/bak"
    for file in $FILES; do
        [[ -d "$file" ]] && bak "$file"
        printf "Backup file %s " "$file"
        [[ -f "$file" ]] && cp -f "$file" "bak/${file}.bak" || echo -e "${WARN}backup unsuccessful - ${MAIN}${file}${RESET_FG}"
        echo ''
    done
}
cdf() {
    cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')" || return 1
}
check_file() {
    local name="${1##*/}"
    local path="${1%/*}"
    echo "name: $name"
    echo "path: $path"
    local tmp_chk=''
    [[ -e "$path" ]] && tmp_chk="${tmp_chk} exists" || tmp_chk="${tmp_chk} does-not-exist"
    [[ -f "$path" ]] && tmp_chk="${tmp_chk} regular"
    [[ -L "$path" ]] && tmp_chk="${tmp_chk} link"
    [[ -d "$path" ]] && tmp_chk="${tmp_chk} directory"
    [[ -r "$path" ]] && tmp_chk="${tmp_chk} readable"
    [[ -s "$path" ]] && tmp_chk="${tmp_chk} size>0"
    [[ -w "$path" ]] && tmp_chk="${tmp_chk} writable"
    [[ -x "$path" ]] && tmp_chk="${tmp_chk} executable"
    [[ -O "$path" ]] && tmp_chk="${tmp_chk} owned-by-me"
    [[ -N "$path" ]] && tmp_chk="${tmp_chk} dirty"
    [[ -k "$path" ]] && tmp_chk="${tmp_chk} sticky"
    echo " ->$tmp_chk"
    echo ''
}
checkpath() {
    # Usage: checkpath [-d DELIMITER] [PATH]
    if [[ "$1" == '-d' ]]; then
        shift
        DELIM="$1"
        shift
    else
        DELIM=':'
    fi
    path_param="${*:-$PATH}" # use all args ... if none, use PATH as default
    path_param="${path_param//$DELIM/ }"  # replace DELIM
    path_param="${path_param//  / } "     # remove duplicate spaces
    # IFS="$'\n\t :'"
    IFS="
     :"
    path_list=( "$(echo -e "$path_param")" )

    for p in ${path_list[*]};
    do
        # shellcheck disable=2015
        [[ -d "$p" ]] && green "$p" || attn "$p"
    done
}
chmod_all() {
    # chmod matching files to given mode
    # $1 is path (default $PWD);
    # $2 is pattern (default '*');
    # $3 is mode (default '644' for files, '755' for directories)
    case "$1" in
    '-h' | '--help' | 'help')
        echo "Usage : $0 [path($PWD)] [pattern(*)] [mode(644)]"
        return "$EX_USAGE"
        ;;
    esac
    # Check the given file is exist #
    if [ ! -f "$3" ]; then
        echo "Filename given \"$3\" doesn't exist"
        return 1
    fi
    find -L "${1:-$PWD}" -name "${2:-'*'}" -type f -print0 | xargs -0 chmod "${3:-644}"
}
# shellcheck disable=2091 #! exec / eval warning ...
clip() { $("$*") | pbcopy; }
colon_list() { echo -e "${1//:/\\n}"; }
dataurl() {
    local mimeType
    mimeType=$(file -b --mime-type "$1")
    if [[ "$mimeType" == text/* ]]; then
        mimeType="${mimeType};charset=utf-8"
    fi
    echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')"
}
datelog() {
    # create a logfile with the date as part of the file_name
    [[ -z $1 ]] && exit 1
    command_text="$*"
    file_name="${PWD}/datelog_$(date "+%m_%d_%y").log"
    printf "\nOutput logged to file: %s\n${file_name}\n"
    printf "\n===================================\n" | tee -a "$file_name"
    printf "Log for %s\n\n" "$(date "+%m/%d/%Y")" | tee -a "$file_name"
    eval "$command_text" | tee -a "$file_name"
    # shellcheck disable=2091 #! exec / eval warning ...
    $("$*") | tee -a "$file_name"
}
digga() {
    dig +nocmd "$1" any +multiline +noall +answer
}
dist_hook() {
    # TODO not yet implemented
    return 0
    # https://stackoverflow.com/a/8969875
    # find -regextype posix-egrep -regex ".*(\.([chyl]|def|cpy|cob|conf|cfg)|(README|ChangeLog|AUTHORS|ABOUT-NLS|NEWS|THANKS|TODO|COPYING.*))$" -exec sed -i -e 's/\r*$/\r/' {} \;
    # OR
    # for F in Documents/*.{py,html}; do ...something with each '$F'... ; done
}
fileop() {
    # TODO work in progress
    return 0
    # File counter, filter, and editor for word or line matches
    # Check 3 arguments are given #
    # if [ "$#" -lt 3 ]; then
    #     echo "Usage : $0 option pattern filename"
    #     return 1
    # fi
    # - # Check the given file is exist #
    # if [ ! -f "$3" ]; then
    #     echo "Filename given \"$3\" doesn't exist"
    #     return 1
    # fi
    # case "$1" in
    # - # Count number of lines matches
    # -i)
    #     echo "Number of lines matches with the pattern $2 :"
    #     fgrep -c -i $2 $3
    #     ;;
    # - # Count number of words matches
    # -c)
    #     echo "Number of words matches with the pattern $2 :"
    #     fgrep -o -i $2 $3 | wc -l
    #     ;;
    # - # print all the matched lines
    # -p)
    #     echo "Lines matches with the pattern $2 :"
    #     fgrep -i $2 $3
    #     ;;
    # - # Delete all the lines matches with the pattern
    # -d)
    #     echo "After deleting the lines matches with the pattern $2 :"
    #     sed -n "/$2/!p" $3
    #     ;;
    # *)
    #     echo "Invalid option"
    #     ;;
    # esac
}
find_broken() {
    # Find and delete all broken symbolic links in current directiry
    # use safety feature $1 == '-d' to actually delete them
    # interesting method:
    # https://stackoverflow.com/a/26887762/9878098
    if [[ "$1" == "-d" ]]; then
        echo "Deleting Broken Symlinks ..."
        find -L "$PWD" -type l -exec rm -- {} +
    else
        echo "Listing Broken Symlinks (use -d to delete links)..."
        find -L "$PWD" -type l -print 2>&1
    fi
}
fix_list() {
    # TODO work in progress
    return 0
    # https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Command-Substitution
    # function_list=$(<~/.dotfiles/.functions | grep -e 'function () { ' | awk '{ printf "%s\\n",$2 }')
    # me "\nAvailable BASH functions (function_list):\n"
    # oe $function_list
    # < ~/.dotfiles/.functions | grep -e " function " | awk '{ print $2 }'
    # echo $function_list >function_list.txt
}
fs() {
    if du -b /dev/null >/dev/null 2>&1; then
        local arg=-sbh
    else
        local arg=-sh
    fi
    if [[ -n "$*" ]]; then
        du $arg -- "$*"
    else
        du $arg .[^.]* ./*
    fi
}
getcertnames() {
    if [ -z "${1}" ]; then
        echo "ERROR: No domain specified."
        return 1
    fi
    local domain="${1}"
    echo "Testing ${domain}…"
    echo ""
    local tmp
    local certText
    tmp=$(echo -e "GET / HTTP/1.0\nEOT" |
        openssl s_client -connect "${domain}:443" -servername "${domain}" 2>&1)
    if [[ "${tmp}" == *"-----BEGIN CERTIFICATE-----"* ]]; then
        certText=$(echo "${tmp}" |
            openssl x509 -text -certopt "no_aux, no_header, no_issuer, no_pubkey, \
                no_serial, no_sigdump, no_signame, no_validity, no_version")
        echo "Common Name:"
        echo ""
        echo "${certText}" | grep "Subject:" | sed -e "s/^.*CN=//" | sed -e "s/\/emailAddress=.*//"
        echo ""
        echo "Subject Alternative Name(s):"
        echo ""
        echo "${certText}" | grep -A 1 "Subject Alternative Name:" |
            sed -e "2s/DNS://g" -e "s/ //g" | tr "," "\n" | tail -n +2
        return 0
    else
        echo "ERROR: Certificate not found."
        return 1
    fi
}
get_template() {
    # TODO work in progress
    return 0
    # - # copy template file <$1> to current directory
    # - # use $2 == '-f' to force overwrite
    # local template_file="${bin_path}/$1"
    # echo "$template_file"
    # if [[ -f "$template_file" ]]; then
    #     if [[ -f "$1" ]]; then
    #         if [[ "$2" == '-f' ]]; then
    #             cp -f "$template_file" .
    #         else
    #             printf "File already exists in current directory. (use -f to force) \n\n"
    #         fi
    #     else
    #         cp "$template_file" .
    #     fi
    # else
    #     printf "SOURCE file not found.\n\n"
    # fi
}
git_one() {
    # TODO work in progress
    # to keep from delaying a commit due to one file that won't pass pre-commit
    FILES=$(gaa -n)
    FILES="${FILES[*]/5/-1}"
    for file in $FILES; do
        fixed_file=${file/5/-1}
        echo "$fixed_file"
    done
}
gz() {
    local origsize
    origsize=$(wc -c <"$1")
    local gzipsize
    gzipsize=$(gzip -c "$1" | wc -c)
    local ratio
    ratio=$(echo "$gzipsize * 100 / $origsize" | bc -l)
    printf "orig: %d bytes\n" "$origsize"
    printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio"
}
lns() {
    # list symlinks in current directory
    # References: https://askubuntu.com/questions/522051/how-to-list-all-symbolic-links-in-a-directory
    # la | grep '\-> \/'
    find "$PWD" -maxdepth 1 -type l
}

# shellcheck disable=2012
lt() { ls -lhtrsA "$@" | tail; }
mkd() {
    mkdir -p "$@" && cd "$_" || return
}
nonzero_return() {
    RETVAL=$?
    [ $RETVAL -ne 0 ] && echo "$RETVAL"
}
o() {
    if [ $# -eq 0 ]; then
        open .
    else
        open "$@"
    fi
}
parse_git_branch() {
    BRANCH=$(git branch 2>/dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    if [ ! "${BRANCH}" == "" ]; then
        STAT=$(parse_git_dirty)
        echo "[${BRANCH}${STAT}]"
    else
        echo ""
    fi
}
parse_git_dirty() {
    status=$(git status 2>&1 | tee)
    dirty=$(
        echo -n "${status}" 2>/dev/null | grep "modified:" &>/dev/null
        echo "$?"
    )
    untracked=$(
        echo -n "${status}" 2>/dev/null | grep "Untracked files" &>/dev/null
        echo "$?"
    )
    ahead=$(
        echo -n "${status}" 2>/dev/null | grep "Your branch is ahead of" &>/dev/null
        echo "$?"
    )
    newfile=$(
        echo -n "${status}" 2>/dev/null | grep "new file:" &>/dev/null
        echo "$?"
    )
    renamed=$(
        echo -n "${status}" 2>/dev/null | grep "renamed:" &>/dev/null
        echo "$?"
    )
    deleted=$(
        echo -n "${status}" 2>/dev/null | grep "deleted:" &>/dev/null
        echo "$?"
    )
    bits=''
    if [ "${renamed}" == "0" ]; then
        bits=">${bits}"
    fi
    if [ "${ahead}" == "0" ]; then
        bits="*${bits}"
    fi
    if [ "${newfile}" == "0" ]; then
        bits="+${bits}"
    fi
    if [ "${untracked}" == "0" ]; then
        bits="?${bits}"
    fi
    if [ "${deleted}" == "0" ]; then
        bits="x${bits}"
    fi
    if [ "${dirty}" == "0" ]; then
        bits="!${bits}"
    fi
    if [ ! "${bits}" == "" ]; then
        echo " ${bits}"
    else
        echo ""
    fi
}
phpserver() {
    local port
    port="${1:-4000}"
    local ip
    ip=$(ipconfig getifaddr en0)
    sleep 1 && open "http://${ip}:${port}/" &
    php -S -c "$PWD" "${ip}:${port}" -
}
pk() { pkill -9 -u "$(id -u "$1")"; } # kill another user's processes
prettier_here() {
    # $1 = path (default $PWD); $2 = filenames ( default '*')
    # OR
    # $1 = 'git'; $2 = "$files"
    if [[ "$1" == 'git' ]]; then
        FILES=$(git diff --cached --name-only | sed 's| |\\ |g')
        echo "${2:-$FILES}" | xargs prettier --write | grep -e '[[:space:]]\?[[:digit:]]\+ms'
    else
        find -L "${1:-$PWD}" -name "${2:-'*'}" -type f -print0 | xargs -0 prettier --write | grep -e '[[:space:]]\?[[:digit:]]\+ms'
    fi
}
pretty() {
    # Use prettier to format all compatible selected files
    # Use $1 for pattern, -m (github diff) or default is '*'
    if [[ -z "$1" ]]; then
        echo "Making all the things pretty! (use pretty -h for help)"
        yes_no 'Make all of the things Prettier? (Y/n) '
        if [ "$?" ]; then
            ce "$_pretty_usage"
        else
            prettier_here
        fi
    else
        case "$1" in
        '-h' | '--help' | 'help')
            ce "$_pretty_usage"
            return "$EX_USAGE"
            ;;
        '-m' | '--commit-message' | 'commit')
            # echo "Making your git staged file pretty ..."
            # select stated files
            FILES=$(git diff --cached --name-only | sed 's| |\\ |g')
            # Prettify all selected files
            prettier_here
            # Add back the modified/prettified files to staging
            echo "$FILES" | xargs git add
            git commit -m "prettybot: $2"
            git status
            ;;
        *)
            prettier_here "$PWD" "$1"
            ;;
        esac
    fi
}
pyver() {
    # silly function to address the lack of correct output from
    #   python 2.7 executable in this sitation 'python --version'
    python -c "print('.'.join(str(i).strip() for i in __import__('sys').version_info[:3]))"
}
readlinkf() { perl -MCwd -e 'print Cwd::abs_path shift' "$1"; }
server() {
    local port="${1:-8000}"
    sleep 1 && open "http://localhost:${port}/" &
    python2 -c 'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port"
}
setup_tools() {
    # TODO Work in progress
    return 0
    # https://www.createdbypete.com/ruby-on-rails-development-setup-for-macos/
    echo "Setup for Homebrew, Node.js, Python, etc."
    echo ''
    if [ "$(yes_no 'Fresh Homebrew and tools setup?')" ]; then
        echo "Homebrew ..."
        /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
        brew update &>/dev/null && brew cleanup &>/dev/null && brew doctor &>/dev/null
        brew install bash zsh coreutils cython python git hub heroku leiningen clojure php node
        brew reinstall node && echo -e "==> Installation successful! node.js $(node -v) installed."
    else
        return 1
    fi
}
targz() {
    local tmpFile="${*%/}.tar"
    tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1
    size=$(
        stat -f"%z" "${tmpFile}" 2>/dev/null
        stat -c"%s" "${tmpFile}" 2>/dev/null
    )
    local cmd=""
    if ((size < 52428800)) && hash zopfli 2>/dev/null; then
        cmd="zopfli"
    else
        if hash pigz 2>/dev/null; then
            cmd="pigz"
        else
            cmd="gzip"
        fi
    fi
    echo "Compressing .tar ($((size / 1000)) kB) using \`${cmd}\`…"
    "${cmd}" -v "${tmpFile}" || return 1
    [ -f "${tmpFile}" ] && rm "${tmpFile}"
    zippedSize=$(
        stat -f"%z" "${tmpFile}.gz" 2>/dev/null
        stat -c"%s" "${tmpFile}.gz" 2>/dev/null
    )
    echo "${tmpFile}.gz ($((zippedSize / 1000)) kB) created successfully."
}
travis_trigger() {
    # TODO needs more testing - strange errors
    return 0
    # Travis CI CLI API
    # Travis CI Client (CLI and Ruby library)
    # https://github.com/travis-ci/travis.rb#mac-os-x-via-homebrew
    # macOS:
    # brew install ruby
    # gem update --system
    #
    # Using the CLI
    # travis login --org --auto
    # travis token
    # You can keep this token in an environment variable TRAVIS_TOKEN, as long as the file you keep it in is not version-controlled somewhere public.
    # I use this function to submit triggers:
    # local org=$1 && shift
    # local repo=$1 && shift
    # local branch=${1:-master} && shift
    # body="{
    #         \"request\": {
    #         \"branch\": \"${branch}\"
    #         }
    #     }"
    # curl -s -X POST \
    #     -H "Content-Type: application/json" \
    #     -H "Accept: application/json" \
    #     -H "Travis-API-Version: 3" \
    #     -H "Authorization: token $TRAVIS_TOKEN" \
    #     -d "$body" \
    #     "https://api.travis-ci.org/repo/${org}%2F${repo}/requests"
}
tre() {
    tree -axC -I '.git|node_modules|bower_components' --dirsfirst "$@" -- | less -FRNX
}
trw() {
    # TODO work in progress
    return 0
    # -     # trim leading and trailing whitespace
    #     local var="$*"
    #     var="${var#"${var%%[![:space:]]*}"}"
    #     var="${var#"${var&&[!'/']*}"}"
    #     var="${var%"${var##*[![:space:]]}"}"
    #     echo -n "$var"
}
tt() {
    # alias treetop='tree -L 1'
    tree -L 1 -- "$@"
}
tree_html() {
    tree -ahlsAFRHD --prune --du --si --dirsfirst >tree.html
}
write_versions_file() {
    br
    me "# Program Versions List"
    me "-------------------------------------------------------------"
    # green "## VERSION_LIST path: $VERSION_LIST"
    blue "**os: $(uname -i) | $(sw_vers -productName) | $(sw_vers -productVersion)**"
    me "### shell:"
    lime "- zsh:            $(zsh --version)"
    # green "- current shell:  $ZSH_VERSION"
    rain "- VSCode:         $(code --version | head -n 1)"
    br
    me "### utilities:"
    warn   "- $(clang --version | grep version | sed 's/version //g')"
    attn   "- $(git --version | sed 's/version //g') with $(hub --version | grep hub | sed 's/version //g')"
    canary "- $(bash --version | grep bash | cut -d ',' -f 1)  ($(bash --version | grep bash | cut -d ' ' -f 4 | cut -d '(' -f 1))${WHITE} with ${GO}GNU grep ($(grep --version | head -n 1 | cut -d ' ' -f 4))${WHITE} and ${CHERRY}GNU coreutils ($(brew list coreutils --versions | cut -d ' ' -f 2))"
    # lime "- homebrew ($(brew --version | tail -n 3 | head -n 1 | cut -d ' ' -f 2))" # and conda ($(conda -V | cut -d ' ' -f 2))"
    canary "- prettier ($(prettier --version))"
    # purple "- stack ($(stack --version | cut -d ',' -f 1 | cut -d ' ' -f 2))"
    blue "- mkdocs ($(mkdocs --version | cut -d ' ' -f 3))"
    # green "- TeXLive(tlmgr)  v$(tlmgr --version | head -n 1 | cut -d ' ' -f 3-4))"
    br

    me "### languages:"
    blue   "- GO      ($(go version | cut -d ' ' -f 3 | sed 's/go//g'))"
    # attn   "- rustc   ($(rustc --version | cut -d ' ' -f 2)) with rustup ($(rustup --version | cut -d ' ' -f 2))"
    warn   "- ruby    ($(ruby -v 2>/dev/null | cut -d ' ' -f 2 | cut -d 'p' -f 1)) with gem ($(gem -v))"
    # purple "- php     ($(php -v 2>/dev/null | grep '(cli)' | cut -d ' ' -f 2)) with composer ($(composer --version | cut -d ' ' -f 3))"
    printf "%s\n" "${COOL}- python  ($(python --version | cut -d ' ' -f 2)) with pip ($(pip --version | cut -d ' ' -f 2)) and pipenv ($(pipenv --version | cut -d ' ' -f 3)) ${RESET_FG}"
    canary "- node    ($(node -v | sed 's/v//g')) with npm ($(npm -v))"
    cherry "- Xcode   ($(/Applications/Xcode.app/Contents/Developer/usr/bin/xcodebuild -version | grep Xcode | sed 's/Xcode //g'))"
    # attn   "- Clojure ($(clojure -Sdescribe | grep version | sed 's/{://g' | sed 's/"//g' | sed 's/version //g')) with lein"
    br

    # attn "- cargo ($(cargo --version | cut -d ' ' -f 2))"
    # attn "  $(lein --version | sed 's/Leiningen/lein version/g' | sed 's/version /       v/g')"

    # me "Travis CI   v$(travis version)"
} >"$VERSION_LIST"
save_versions() {
    # echo "VERSION_LIST: $VERSION_LIST"
    rm -rf "$VERSION_LIST" >/dev/null
    # touch $VERSION_LIST
    write_versions_file
}
versions() {
    cat ~/.dotfiles/.VERSION_LIST.md
}
web_chmod() {
    # Set default permissions for a folder that will be uploaded to the web.
    # default directory is PWD
    # most files = 644; directories = 755
    [[ -d "$1" ]] && dir="$1" || dir=$PWD
    find -LX "$dir" -type f -print0 | xargs -0 chmod 644
    echo "Changing permissions of all regular files to 0644."
    find -LX "$dir" -type d -print0 | xargs -0 chmod 755
    echo "Changing permissions of all regular directories to 0755."
    # ls "$dir" -ARlh
}

#? ######################## SCRIPT TESTS
_run_debug_functions() {
    db_script_source "Functions test"
    warn "$name"
}
#? ######################## BEGIN SCRIPT SETUP
# _run_setup() {

# }
_login_message() {
    br
    me "os: ${LIME}$(uname -i) | $(sw_vers -productName) | $(sw_vers -productVersion)"
    me "shell: ${LIME}zsh: $(zsh --version)"
    # green "  this zsh session: $ZSH_VERSION"
    br
    green "Use <versions> to display shell, language, and utility versions. (Use <checkpath> to check system \$PATH.)"
    br
}
#? ######################## MAIN LOOP
_main_loop() {
    # _run_setup
    _login_message
    save_versions & # 2>/dev/null
    # echo "Travis test: $TRAVIS_TOKEN"
    # travis login --github-token "$TRAVIS_TOKEN"
    [[ $SET_DEBUG == '1' ]] && _run_debug_functions
}

#? ######################## PROGRAM FEATURES:
    #  Symlink a file in ~/.dotfiles to ~/
    #  This makes managing a 'dotfiles' Git repo more efficient
    #  - Make Numbered backup copies in ~/.dotfiles/bak (not synced to repo)
    #  - Copy file to ~/.dotfiles if needed
    #  - Delete original file if needed
    #  - Delete original symlink if needed
#? ######################## skeptycal.com
declare -x GATHER_USAGE
GATHER_USAGE="$(
    cat <<GATHER_USAGE
    ${MAIN:-}gather${WHITE:-} construct argument list from all similar files in the current
    directory / all subdirectories and execute optional <utility> program

${MAIN:-}Usage:${WHITE:-}

${MAIN:-}gather${WHITE:-} [-htuv] [-0opt] [-E eofstr] [-I replstr [-R replacements]] [-J replstr]
    [-L number] [-n number [-x]] [-P maxprocs] [-s size] [utility [argument ...]]

Tested on ${LIME:-}macOS Catalina${WHITE:-} with ${COOL:-}Python ${CANARY:-}3.8${WHITE:-}
GATHER_USAGE
)"

#? ######################## ENTRY POINT
_main_loop "$@"

#?#- ##########################- ############################################
# generate a function list
# declare -F | sed "s/declare -fx //g" >.functions_functions.txt
# References:
# 	'find types' https://www.gnu.org/software/findutils/manual/html_mono/find.html#Type
# pipe $2 with $1 using |&  https://unix.stackexchange.com/questions/128975/why-doesnt-grep-using-pipe-work-here
# mkdir ref: https://www.cyberciti.biz/tips/bash-shell-parameter-substitution-2.html
