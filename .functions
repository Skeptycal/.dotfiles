#!/usr/bin/env false bash
# -*- coding: utf-8 -*-
# cannot be run directly

# identify this actual script name and current directory path
# _self=${0##*/}
# parameter expansion to remove trailing /filename
# _path="${0%/*}"

source $(which brew_fix.sh)

function source_file() {
    if [[ -f "$1" ]]; then
        if [[ -r "$1" ]]; then
            source "$1"
        else
            db_echo "source file ${1} is not readable."
        fi
    else
        db_echo "source file ${1} not found."
    fi
    }

function _initialize_functions() {
    script_source="$(dirname "${BASH_SOURCE}")"
    bin_path="${HOME}/bin/utilities/pc_bak"
    here=$PWD

    source_file "${HOME}/.dotfiles/.blurbs"
    # source_file "${HOME}/.dotfiles/.travis_token_private.sh"

    if [ ! "$(uname -s)" = 'Darwin' ]; then
        if grep -q Microsoft /proc/version; then
            alias open='explorer.exe'
        else
            alias open='xdg-open'
        fi
    fi

    if [[ "$(hash git &>/dev/null)" -eq 0 ]]; then
        function diff() {
            git diff --no-index --color-words "$@"
        }
    fi

    if which brew &>/dev/null && [ -f "$(brew --prefix)/share/bash-completion/bash_completion" ]; then
        source "$(brew --prefix)/share/bash-completion/bash_completion"
    elif [ -f /etc/bash_completion ]; then
        source /etc/bash_completion
    fi

    if type _git &>/dev/null && [ -f /usr/local/etc/bash_completion.d/git-completion.bash ]; then
        complete -o default -o nospace -F _git g
    fi

    if [ -d "/usr/local/etc/bash_completion.d" ]; then
        for file in $(ls -A /usr/local/etc/bash_completion.d); do
            oe "loading $file"
            source_file "$file" # &>/dev/null # used to test for errors
        done
        unset file
    fi
    }
function _load_functions() {
    function fix_list() {
        function_list=$(cat ~/.dotfiles/.functions | grep -e 'function () { ' | awk '{ printf "%s\\n",$2 }')

        me "\nAvailable BASH functions (function_list):\n"
        oe $function_list
        # cat ~/.dotfiles/.functions | grep -e " function " | awk '{ print $2 }'
        # echo $function_list >function_list.txt
        }

    function travis_trigger() {
        # Travis CI CLI API
        # Travis CI Client (CLI and Ruby library)
        # https://github.com/travis-ci/travis.rb#mac-os-x-via-homebrew

        # macOS:
        # brew install ruby
        # gem update --system
        #

        # Using the CLI

        # travis login --org --auto
        # travis token
        # You can keep this token in an environment variable TRAVIS_TOKEN, as long as the file you keep it in is not version-controlled somewhere public.

        # I use this function to submit triggers:

        local org=$1 && shift
        local repo=$1 && shift
        local branch=${1:-master} && shift

        body="{
                \"request\": {
                \"branch\": \"${branch}\"
                }
            }"

        curl -s -X POST \
            -H "Content-Type: application/json" \
            -H "Accept: application/json" \
            -H "Travis-API-Version: 3" \
            -H "Authorization: token $TRAVIS_TOKEN" \
            -d "$body" \
            "https://api.travis-ci.org/repo/${org}%2F${repo}/requests"
        }

    function tree_html() {
        tree -ahlsAFRHD --prune --du --si --dirsfirst >tree.html
        }

    function versions() {
        ge "BASH $BASH_VERSION"
        oe "$(hub --version)"
        he "ruby        v$(ruby -v 2>/dev/null | awk '{print $2}')"
        pe "php         v$(php -v | grep '(cli)' | awk '{print $2}')"

        printf "${COOL}"
        python -c 'import sys; sys.stdout.write("python      v" + ".".join(map(str, sys.version_info[:3]))); sys.stdout.flush()'
        printf "$RESET\n"

        ye "node        $(node -v)"
        we "npm         v$(npm -v)"
        br
        # me "Travis CI   v$(travis version)"

        # ye "eslint $(eslint -v)"
        # echo "$(pipenv --version)"
        # oe "prettier v$(prettier -v)"
        }

    function readlinkf(){ perl -MCwd -e 'print Cwd::abs_path shift' "$1";}
    function check_file() {
        local name=${1##*/}
        local path=${1%/*}
        echo "name: $name"
        echo "path: $path"
        local tmp_chk=''
        [[ -e "$path" ]] && tmp_chk="${tmp_chk} exists" || tmp_chk="${tmp_chk} does-not-exist"
        [[ -f "$path" ]] && tmp_chk="${tmp_chk} regular"
        [[ -L "$path" ]] && tmp_chk="${tmp_chk} link"
        [[ -d "$path" ]] && tmp_chk="${tmp_chk} directory"
        [[ -r "$path" ]] && tmp_chk="${tmp_chk} readable"
        [[ -s "$path" ]] && tmp_chk="${tmp_chk} size>0"
        [[ -w "$path" ]] && tmp_chk="${tmp_chk} writable"
        [[ -x "$path" ]] && tmp_chk="${tmp_chk} executable"
        [[ -O "$path" ]] && tmp_chk="${tmp_chk} owned-by-me"
        [[ -N "$path" ]] && tmp_chk="${tmp_chk} dirty"
        [[ -k "$path" ]] && tmp_chk="${tmp_chk} sticky"
        echo " ->$tmp_chk"
        echo ''
        }
    function pretty() {
        # Use prettier to format all compatible selected files
        # Use $1 for pattern, -g (github diff) or default is '*'
        if [[ -z "$1" ]]; then
            echo "Making all the things pretty! (use pretty -h for help)"
            find -L "$PWD" -type f -print0 | xargs -0 prettier --write |& grep -e '[[:space:]]\?[[:digit:]]\+ms'
        else
            case "$1" in
                '-h'|'--help'|'help')
                    echo -e $pretty_usage
                    ;;
                '-m' | '--commit-message' | 'commit')
                    echo "Making your git staged file pretty ..."
                    # select stated files
                    FILES=$(git diff --cached --name-only | sed 's| |\\ |g')
                    # Prettify all selected files
                    echo "$FILES" | xargs prettier --write |& grep -e '[[:space:]]\?[[:digit:]]\+ms'
                    # Add back the modified/prettified files to staging
                    echo "$FILES" | xargs git add
                    git commit -m "gitbot: $2"
                    git status
                    ;;
                *)
                    echo "Making $1 pretty ..."
                    find -L "$PWD" -name "$1" -type f -print0 | xargs -0 prettier --write |& grep -e '[[:space:]]\?[[:digit:]]\+ms'
                    ;;
            esac
        fi
        }

    function fileop() {
        # Check 3 arguments are given #
        if [ "$#" -lt 3 ]
        then
            echo "Usage : $0 option pattern filename"
            return 1
        fi

        # Check the given file is exist #
        if [ ! -f "$3" ]
        then
            echo "Filename given \"$3\" doesn't exist"
            return 1
        fi

        case "$1" in

            # Count number of lines matches
            -i) echo "Number of lines matches with the pattern $2 :"
                fgrep -c -i $2 $3
                ;;
            # Count number of words matches
            -c) echo "Number of words matches with the pattern $2 :"
                fgrep -o -i $2 $3 | wc -l
                ;;
            # print all the matched lines
            -p) echo "Lines matches with the pattern $2 :"
                fgrep -i $2 $3
                ;;
            # Delete all the lines matches with the pattern
            -d) echo "After deleting the lines matches with the pattern $2 :"
                sed -n "/$2/!p" $3
                ;;
            *) echo "Invalid option"
                ;;
        esac
        }

    function clip() {
        echo "$("$@")" | pbcopy
        }

    function get_template() {
        ## copy template file <$1> to current directory
        ## use $2 == '-f' to force overwrite
        local template_file="$bin_path//$1"
        echo "$template_file"
        if [[ -f "$template_file" ]]; then
            if [[ -f "$1" ]]; then
                if [[ "$2" == '-f' ]]; then
                    cp -f "$template_file" .
                else
                    printf "File already exists in current directory. (use -f to force) \n\n"
                fi
            else
                cp "$template_file" .
            fi
        else
            printf "SOURCE file not found.\n\n"
        fi
        }

    function web_chmod() {
        # Set default permissions for a folder that will be uploaded to the web.
        # default directory is PWD
        # most files = 644; directories = 755
        [[ -d "$1" ]] && dir="$1" || dir=$PWD
        find -LX "$dir" -type f -print0 | xargs -0 chmod 644
        echo "Changing permissions of all regular files to 0644."
        find -LX "$dir" -type d -print0 | xargs -0 chmod 755
        echo "Changing permissions of all regular directories to 0755."
        # ls "$dir" -ARlh
        }

    function find_broken() {
        # Find and delete all broken symbolic links in current directiry
        # use safety feature $1 == '-d' to actually delete them
        if [[ "$1" == "-d" ]]; then
            echo "Deleting Broken Symlinks ..."
            find -L $PWD -type l -exec rm -- {} +
        else
            echo "Listing Broken Symlinks (use -d to delete links)..."

            find -L $PWD -type l -print 2>&1

            # for shorter names (basenames) + error messages
            # find -LX $PWD -type l -print 2>&1 |awk -F"/" '{print $NF}'        # interesting method:
            # https://stackoverflow.com/a/26887762/9878098
            # find -LX $PWD -type l -print 2>&1 | rev | cut -d '/' -f1 | rev | cut -d ' ' -f1

            # color errors:
            # fgrep illegal --color=always
        fi
        }

    function trw() {
        # trim leading and trailing whitespace
        local var="$*"
        var="${var#"${var%%[![:space:]]*}"}"

        var="${var#"${var&&[!'/']*}"}"
        var="${var%"${var##*[![:space:]]}"}"
        echo -n "$var"
        }

    function git_one() {
        # TODO work in progress
        # to keep from delaying a commit due to one file that won't pass pre-commit
        FILES=$(gaa -n)
        FILES=${FILES[@]/5/-1}
        for file in $FILES; do
            fixed_file=${file/5/-1}
            echo "$fixed_file"
        done
        }

    function bak() {
        FILES="$@"
        [[ -d "$PWD/bak" ]] || mkdir bak
        for file in $FILES; do
            [[ -d "$file" ]] && continue
            printf "Backup file %s " $file
            [[ -f "$file" ]] && cp -f "$file" "bak/${file}.bak" || echo -e "${WARN}unsuccessful!${RESET}"
            echo ''
        done
        }

    function pyver() {
        # silly function to address the lack of correct output from
        #   python 2.7 executable in this sitation 'python --version'
        python -c "print('.'.join(str(i).strip() for i in __import__('sys').version_info[:3]))"
        }

    function setup_tools() {
        # TODO Work in progress
        # https://www.createdbypete.com/ruby-on-rails-development-setup-for-macos/
        echo "Setup for Homebrew, Node.js, Python, etc."
        # echo ''
        # echo "Homebrew ..."
        # /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
        # brew update &>/dev/null && brew cleanup &>/dev/null && brew doctor &>/dev/null
        # brew reinstall node &&	echo -e "==> Installation successful! node.js $(node -v) installed.""
        }

    function nonzero_return() {
        RETVAL=$?
        [ $RETVAL -ne 0 ] && echo "$RETVAL"
        }
    function parse_git_branch() {
        BRANCH=$(git branch 2>/dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
        if [ ! "${BRANCH}" == "" ]; then
            STAT=$(parse_git_dirty)
            echo "[${BRANCH}${STAT}]"
        else
            echo ""
        fi
        }

    function parse_git_dirty() {
        status=$(git status 2>&1 | tee)
        dirty=$(
            echo -n "${status}" 2>/dev/null | grep "modified:" &>/dev/null
            echo "$?"
        )
        untracked=$(
            echo -n "${status}" 2>/dev/null | grep "Untracked files" &>/dev/null
            echo "$?"
        )
        ahead=$(
            echo -n "${status}" 2>/dev/null | grep "Your branch is ahead of" &>/dev/null
            echo "$?"
        )
        newfile=$(
            echo -n "${status}" 2>/dev/null | grep "new file:" &>/dev/null
            echo "$?"
        )
        renamed=$(
            echo -n "${status}" 2>/dev/null | grep "renamed:" &>/dev/null
            echo "$?"
        )
        deleted=$(
            echo -n "${status}" 2>/dev/null | grep "deleted:" &>/dev/null
            echo "$?"
        )
        bits=''
        if [ "${renamed}" == "0" ]; then
            bits=">${bits}"
        fi
        if [ "${ahead}" == "0" ]; then
            bits="*${bits}"
        fi
        if [ "${newfile}" == "0" ]; then
            bits="+${bits}"
        fi
        if [ "${untracked}" == "0" ]; then
            bits="?${bits}"
        fi
        if [ "${deleted}" == "0" ]; then
            bits="x${bits}"
        fi
        if [ "${dirty}" == "0" ]; then
            bits="!${bits}"
        fi
        if [ ! "${bits}" == "" ]; then
            echo " ${bits}"
        else
            echo ""
        fi
        }

    function allopen() { sudo lsof -i -P | grep "$1"; }
    function a() { alias | grep "$1"; }
    function lt() { ls -ltrsA "$@" | tail; }
    function anybar() { echo -n "$1" | nc -4u -w0 localhost "${2:-1738}"; }
    function azure_agent() {
        if [ -n "${1}" ] && [ -d "${1}" ] && [ -f "${1}/svc.sh" ]; then
            working_dir="${1}/"
        else
            working_dir="$HOME/myagent/"
        fi
        if [ -z "${2}" ]; then
            param="status"
        else
            param="${2}"
        fi
        temp_pwd=$("PWD")
        cd "$working_dir" || return
        ./svc.sh "$param"
        result="$?"
        echo "result $result"
        cd "$temp_pwd" || return
        return "$result"
        }

    function datelog() {
        # create a logfile with the date as part of the file_name
        [[ -z $1 ]] && exit 1
        command_text="$@"
        file_name="${PWD}/datelog_$(date "+%m_%d_%y").log"
        printf "\nOutput logged to file: %s\n${file_name}\n"
        printf "\n===================================\n" | tee -a "$file_name"
        printf "Log for %s\n\n" $(date "+%m/%d/%Y") | tee -a "$file_name"
        exec "$command_text" | tee -a "$file_name"
        $("$@") | tee -a "$file_name"
        }

    function mkd() {
        mkdir -p "$@" && cd "$_" || return
        }

    function cdf() {
        cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')" || return 1
        }

    function targz() {
        local tmpFile="${*%/}.tar"
        tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1

        size=$(
            stat -f"%z" "${tmpFile}" 2>/dev/null
            stat -c"%s" "${tmpFile}" 2>/dev/null
        )

        local cmd=""
        if ((size < 52428800)) && hash zopfli 2>/dev/null; then
            cmd="zopfli"
        else
            if hash pigz 2>/dev/null; then
                cmd="pigz"
            else
                cmd="gzip"
            fi
        fi

        echo "Compressing .tar ($((size / 1000)) kB) using \`${cmd}\`…"
        "${cmd}" -v "${tmpFile}" || return 1
        [ -f "${tmpFile}" ] && rm "${tmpFile}"

        zippedSize=$(
            stat -f"%z" "${tmpFile}.gz" 2>/dev/null
            stat -c"%s" "${tmpFile}.gz" 2>/dev/null
        )

        echo "${tmpFile}.gz ($((zippedSize / 1000)) kB) created successfully."
        }

    function fs() {
        if du -b /dev/null >/dev/null 2>&1; then
            local arg=-sbh
        else
            local arg=-sh
        fi
        if [[ -n "$*" ]]; then
            du $arg -- "$*"
        else
            du $arg .[^.]* ./*
        fi
        }


    function dataurl() {
        local mimeType
        mimeType=$(file -b --mime-type "$1")
        if [[ $mimeType == text/* ]]; then
            mimeType="${mimeType};charset=utf-8"
        fi
        echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')"
        }

    function server() {
        local port="${1:-8000}"
        sleep 1 && open "http://localhost:${port}/" &
        python2 -c 'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port"
        }

    function phpserver() {
        local port
        port="${1:-4000}"
        local ip
        ip=$(ipconfig getifaddr en0)
        sleep 1 && open "http://${ip}:${port}/" &
        php -S -c "$PWD" "${ip}:${port}" -
        }

    function gz() {
        local origsize
        origsize=$(wc -c <"$1")
        local gzipsize
        gzipsize=$(gzip -c "$1" | wc -c)
        local ratio
        ratio=$(echo "$gzipsize * 100 / $origsize" | bc -l)
        printf "orig: %d bytes\n" "$origsize"
        printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio"
        }

    function digga() {
        dig +nocmd "$1" any +multiline +noall +answer
        }

    function getcertnames() {
        if [ -z "${1}" ]; then
            echo "ERROR: No domain specified."
            return 1
        fi

        local domain="${1}"
        echo "Testing ${domain}…"
        echo ""

        local tmp
        local certText
        tmp=$(echo -e "GET / HTTP/1.0\nEOT" |
            openssl s_client -connect "${domain}:443" -servername "${domain}" 2>&1)
        if [[ "${tmp}" == *"-----BEGIN CERTIFICATE-----"* ]]; then
            certText=$(echo "${tmp}" |
                openssl x509 -text -certopt "no_aux, no_header, no_issuer, no_pubkey, \
                no_serial, no_sigdump, no_signame, no_validity, no_version")
            echo "Common Name:"
            echo ""
            echo "${certText}" | grep "Subject:" | sed -e "s/^.*CN=//" | sed -e "s/\/emailAddress=.*//"
            echo ""
            echo "Subject Alternative Name(s):"
            echo ""
            echo "${certText}" | grep -A 1 "Subject Alternative Name:" |
                sed -e "2s/DNS://g" -e "s/ //g" | tr "," "\n" | tail -n +2
            return 0
        else
            echo "ERROR: Certificate not found."
            return 1
        fi
        }


    function o() {
        if [ $# -eq 0 ]; then
            open .
        else
            open "$@"
        fi
        }

    function tre() {
        tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX
        }
    }

function _run_debug_functions() {
    db_echo "Script source:${MAIN} ${BASH_SOURCE}${RESET}"
    }

function main_functions() {
    _initialize_functions
	_load_functions
    versions
    # echo "Travis test: $TRAVIS_TOKEN"
    # travis login --github-token "$TRAVIS_TOKEN"
	# [ $DEBUG = '1' ] && _run_debug_functions
    }

main_functions

# References:
# 	'find types' https://www.gnu.org/software/findutils/manual/html_mono/find.html#Type
# find . -name '*.[ch]' -print0 | xargs -r -0 grep -l thing
# pipe $2 with $1 using |&  https://unix.stackexchange.com/questions/128975/why-doesnt-grep-using-pipe-work-here

# https://gist.github.com/datchley/f7619bd32213af648885
# <<snippets

#     # disable builtin echo so we can use '-en'
#     enable -n echo

#     SCRIPT=$(basename "$0")
#     SCRIPT_DIR=$(dirname "$0")
#     echo "$SCRIPT running from $SCRIPT_DIR"

#     # Determine if we're interactive or not
#     # is_interactive() { test -t 0; }
#     use_ansi() { test -t 1; }


#     # only output colors if our output is to terminal
#     if use_ansi ; then
#         GREEN="\033[0;32m"
#         RED="\033[0;31m"
#         YELLOW="\033[0;33m"
#         BOLD_WHITE="\033[1;37m"
#         CLEAR="\033[0m"
#     else
#         GREEN=""
#         RED=""
#         YELLOW=""
#         BOLD_WHITE=""
#         CLEAR=""
#     fi

#     # ANSI color output helpers
#     green() { echo -en "${GREEN}"$@"${CLEAR}"; }
#     red() { echo -en "${RED}"$@"${CLEAR}"; }
#     yellow() { echo -en "${YELLOW}"$@"${CLEAR}"; }
#     hl() { echo -en "${BOLD_WHITE}"$@"${CLEAR}"; }

#     # output stuff to terminal
#     log() { echo -en "$@"; }
#     logfmt() { printf "$@"; }

#     # Extended RegExp matching on arguments
#     # $1 = regex pattern
#     # $@... = remaining args as string to match against
#     matches() {
#         local pat=$1; shift
#         echo "$@" | grep -qEi "$pat" >/dev/null 2>&1
#     }

#     pass() {
#         local check="✔"
#         green $check
#     }

#     fail() {
#         local x="✘"
#         red $x
#     }

#     # trim leading/trailing whitespace in string
#     trim() {
#         echo "$@" | awk '{ gsub(/^ +| +$/,"") }{ print $0 }'
#     }

#     # repeat character $1 for $2 times
#     repeat() {
#     echo $(printf "%${2}s" |tr " " "$1")
#     }

#     # is_available COMMAND [TEST]
#     # Check if 'command' is available and if passed
#     # execute TEST as well
#     # returns command line status of both
#     is_available() {
#         local cmd=$1; shift
#         local res=0
#         hash $cmd >/dev/null 2>&1 || { local res=1; }
#         if [ $# -ge 1 ]; then
#             $@ >/dev/null 2>&1 || { local res=2; }
#         fi
#         # echo -n $res
#         return $res
#     }

#     filesize() {
#         local filename=$1; shift
#         echo $(du -k "$filename" | cut -f1)
#     }

#     truncate() {
#         local len=$1; shift;
#         echo "$*" | awk -v len=$len '{ if (length($0) > len) print substr($0, 1, len-3) "..."; else print; }'
#     }

#     escape() {
#         echo "$1" | sed 's/\([\.\$\*]\)/\\\1/g'
#     }

#     escapeSlashes() {
#         echo "$@" | sed 's/\\/\\\\/g'
#     }

#     # Convert UCS-2/UTF-16 with BOM file encoding to UTF-8 w/o BOM
#     # ucs2utf8 DIR FILE_PATTERN
#     # where
#     #   - DIR is the root directory to find files for conversion
#     #   - FILE_PATTERN is `find` pattern to match file names
#     ucs2utf8() {
#         local count=0
#         local converted=0
#         local DIR=$1
#         local FILE_PAT=$2

#         # Ensure we can handle filenames w/ spaces in them
#         local oldIFS=$IFS
#         IFS=$(echo -en "\n\b")

#         for file in $(find $DIR -name $FILE_PAT 2>/dev/null); do
#             count=$((count + 1))
#             # If it has a BOM and first character after is nul (00), convert it
#             if od -x "$file" | head -1 | cut -d' ' -f 2,3 | grep "feff 00" >/dev/null 2>&1; then
#                 log "Converting $(hl ${file}) to UTF-8........"
#                 converted=$((converted + 1))
#                 local tmp="${file}.tmp"
#                 mv "${file}" "${tmp}"
#                 iconv -c -f UCS-2 -t UTF-8 "${tmp}" > "${file}"
#                 rm "${tmp}"
#                 log "$(pass)\n"
#             fi
#         done
#         IFS=$oldIFS
#         echo "$converted/$count"
#     }


#     while IFS= read -r line
#     do
#         if matches "^if\s+" $line; then
#             log $(hl "found: ") $(green $line) "\n"
#             log $(yellow "A warning line...")"\n"
#             log $(red "An error line...")"\n"
#         fi
#     done < t.sh

#     logfmt "%20.20b %20.20b" $(green "test") $(yellow "again")
# snippets
# <<precommit
#     #
#     # @file pre-commit
#     # @author David Atchley, <david.atchley@answers.com>
#     # @date Wed Dec 18 14:02:39 CST 2013
#     #
#     # Pre Commit checks for various syntax and cleaning prio
#     # to committing.  Exits with non-zero to stop commit
#     #
#     #----------------------------------------------------------------------

#     # Handle any options via environment
#     if [ "$GIT_HOOK_PRECOMMIT_IGNORE" = "yes" ]; then
#         exit 0;
#     fi

#     # pluralize a word based on a count
#     s() {
#         local word=$1
#         local count=$2
#         if [ $count -eq 1 ]; then
#             echo $word
#         else
#             if 	  echo "$word" | egrep "([sxz]|[cs]h)$" 2>&1 >/dev/null ; then
#                 echo $word"es";
#             elif  echo "$word" | egrep "y$" 2>&1 >/dev/null ; then
#                 echo $word"ies";
#             else
#                 echo $word"s"
#             fi
#         fi
#     }


#     if git rev-parse --verify HEAD >/dev/null 2>&1
#     then
#         against=HEAD
#     else
#         # Initial commit: diff against an empty tree object
#         against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
#     fi


#     # Redirect output to stderr.
#     exec 1>&2

#     # track number of pre-commit errors found
#     errors=0

#     echo "> Pre Commit Hook running"
#     echo "> You can by-pass this hook by running: export GIT_HOOK_PRECOMMIT_IGNORE=yes"
#     for file in `git diff-index --name-status $against -- | cut -c3-`
#     do

#         # Javascript pre-commit checks
#         if echo "$file" | egrep '\.(p?html|js)$' 2>&1 >/dev/null
#         then
#             # Make sure no 'console.*' calls are in any HTML/JS files
#             if  egrep "(debugger;|console\.)" $file | egrep -v "(\/\/|\/\*|#).*(debugger;|console\.)" 2>&1 >/dev/null
#             then
#                 echo "==> warning: $file contains 'console' or 'debugger' calls!!";
#                 errors=$((errors+1))
#             fi
#         fi

#         # PHP pre-commit checks
#         if echo "$file" | egrep '\.php$' 2>&1 >/dev/null
#         then
#             # Make sure no 'console.*' calls are in any HTML/JS files
#             if  egrep "util::debug" $file | egrep -v "(\/\/|\/\*|#).*util::debug" 2>&1 >/dev/null
#             then
#                 echo "==> warning: $file contains 'util::debug' calls!!";
#                 errors=$((errors+1))
#             fi
#         fi

#     done

#     if [ $errors -gt 0 ]; then
#         echo "=== fail. $errors "$(s 'error' $errors)" found"
#         exit 1
#     else
#         echo "=== ok."
#         exit 0
#     fi
# precommit
