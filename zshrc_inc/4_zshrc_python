#!/usr/bin/env false zsh
# -*- coding: utf-8 -*-
    # shellcheck shell=bash
    # shellcheck source=/dev/null
    # shellcheck disable=2230,2086

#? ######################## Python Config
    #* should not be run directly; called from .bash_profile / .bashrc / .zshrc

    #* copyright (c) 2019 Michael Treanor
    #* MIT License - https://www.github.com/skeptycal

#? ######################## Python
    unset PYTHONDONTWRITEBYTECODE
    #   set hash seed to different random number every session
    declare -ix PYTHONHASHSEED && PYTHONHASHSEED=$(shuf -i1-4294967295 -n1)
    declare -x PYTHONIOENCODING && PYTHONIOENCODING='UTF-8'

    #   pyenv
    [[ $(command -v pyenv >/dev/null) ]] && eval "$(pyenv init -)"
    [[ $(command -v pyenv-virtualenv-init >/dev/null) ]] && eval "$(pyenv virtualenv-init -)"

# *############################################## python aliases

    # As of pip 20.2.2
    # 	this is a new option to resolve dependencies
    # 	--use-feature=2020-resolver
    alias pip='pip --use-feature=2020-resolver '
    alias piu='pip install -U --use-feature=2020-resolver '

    # 'piplist' is not part of the normal python installation. It returns a
    # list of names of installed packages suitable for process and piping,
    # without the header and extra fields. The function recreates the list on
    # demand so it is always current.
    piplist() { pip list | sed 's/  */ /g' | cut -d ' ' -f 1 | tail -n +3; }

    # The constant version is precalculated once and will
    # always contain the global pip list from shell start time.
    PIPLIST=$(pip list | sed 's/  */ /g' | cut -d ' ' -f 1 | tail -n +3; )

    # change all .py files in current folder to executable
    alias modpy='chmod +x *.py -c --preserve-root -- '

    # display current python
    alias pypath='python -c "import sys; print(sys.path)" | tr "," "\n" | grep -v "egg"'

    # clean out stale pycache files
    alias pycclean='find $PWD -name "*.pyc" -exec rm {} \; && find $PWD -name "__pycache__" -exec rm -rf {} \;'

    # virtual environment
    alias pyv="python -m venv .venv"
    alias sba='source .venv/bin/activate || source venv/bin/activate' # older path was 'venv'
    alias sda='deactivate'

    alias py="python -m "

    alias dj="python3 manage.py runserver"
    alias servethis="python -c 'import SimpleHTTPServer; SimpleHTTPServer.test()'"

    # ! these hide configuration errors where aliases are ignored in poetry
    # alias python='python3 '
    # alias pip='pip3 '

# *############################################## poetry
    alias p="poetry "
    alias pu="poetry update"
    alias pb="poetry build"
    alias pub="poetry publish --build"

    # poetry init [--name <...>] [--description <...>] [--author <...>] [--dependency <...>] [--dev-dependency <...>] [-l <...>]
    alias pi='poetry init'
    alias pos='poetry show'
    alias pst="poetry show --tree"
    alias prr='poetry export -f requirements.txt >requirements.txt'

    #   python sucks ... virtual environments suck ...
    #   someone should find a better way to do this ... it's so stupid
    #   'poetry' is the best alternative for now
    export POETRY_REPOSITORIES_TESTPYPI_URL=https://test.pypi.org/legacy/
    export POETRY_PYPI_TOKEN_TESTPYPI='<token>'

    export POETRY_CACHE_DIR=~/Library/Caches/pypoetry
    export POETRY_VIRTUALENVS_PATH=${POETRY_CACHE_DIR}/virtualenvs
    export POETRY_PYPI_TOKEN_PYPI=my-token

# *############################################## pipenv
    # * I use Poetry instead of PipEnv for now
    # alias pe='pipenv'
    # alias pes='pipenv shell'
    # alias pei='pipenv install'
    # alias peg='pipenv graph'
    # alias ve="virtualenv"
    # alias vew="virtualenvwrapper"

# *############################################## other.........................
    #   declare -x PKG_CONFIG_PATH && PKG_CONFIG_PATH="/usr/local/opt/python@3.8/lib/pkgconfig"
    #   declare -x WORKON_HOME && WORKON_HOME="${HOME}/.virtualenvs"
    #   declare -x PROJECT_HOME && PROJECT_HOME="${HOME}/Documents/coding/"
